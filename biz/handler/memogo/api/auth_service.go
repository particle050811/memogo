// Code generated by hertz generator.

package api

import (
	"context"
	"errors"
	"memogo/biz/dal/db"
	"memogo/biz/dal/repository"
	"memogo/biz/model/memogo/api"
	"memogo/biz/service"
	"memogo/pkg/jwt"
	"memogo/pkg/middleware"
	"strings"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// Register .
// @router /v1/auth/register [POST]
func Register(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.RegisterReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// 创建 service
	userRepo := repository.NewUserRepository(db.DB)
	authService := service.NewAuthService(userRepo)

	// 调用注册服务
	accessToken, refreshToken, err := authService.Register(req.Username, req.Password)
	if err != nil {
		// 根据不同错误返回不同状态码
		if errors.Is(err, repository.ErrUserAlreadyExists) {
			c.JSON(consts.StatusBadRequest, &api.AuthResp{
				Status: 400,
				Msg:    "Username already exists",
			})
			return
		}
		c.JSON(consts.StatusInternalServerError, &api.AuthResp{
			Status: 500,
			Msg:    "Registration failed: " + err.Error(),
		})
		return
	}

	resp := &api.AuthResp{
		Status: 200,
		Msg:    "Registration successful",
		Data: &api.TokenPair{
			AccessToken:      accessToken,
			RefreshToken:     refreshToken,
			AccessExpiresIn:  computeExpiresIn(accessToken),
			RefreshExpiresIn: computeExpiresIn(refreshToken),
		},
	}

	c.JSON(consts.StatusOK, resp)
}

// Login .
// @router /v1/auth/login [POST]
func Login(ctx context.Context, c *app.RequestContext) {
	// 使用 Hertz JWT 中间件的 LoginHandler
	middleware.JWTMiddleware.LoginHandler(ctx, c)
}

// RefreshToken .
// @router /v1/auth/refresh [POST]
func RefreshToken(ctx context.Context, c *app.RequestContext) {
	var req api.RefreshReq
	if err := c.BindAndValidate(&req); err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	refreshToken := strings.TrimSpace(req.GetRefreshToken())
	if refreshToken == "" {
		authHeader := strings.TrimSpace(string(c.Request.Header.Peek("Authorization")))
		if strings.HasPrefix(strings.ToLower(authHeader), "bearer ") {
			refreshToken = strings.TrimSpace(authHeader[len("Bearer "):])
		} else if authHeader != "" {
			refreshToken = authHeader
		}
		if refreshToken == "" {
			c.JSON(consts.StatusBadRequest, &api.AuthResp{
				Status: 400,
				Msg:    "Invalid refresh token",
			})
			return
		}
	}

	userRepo := repository.NewUserRepository(db.DB)
	authService := service.NewAuthService(userRepo)

	accessToken, newRefreshToken, err := authService.RefreshToken(refreshToken)
	if err != nil {
		status := consts.StatusInternalServerError
		msg := "Refresh token failed: " + err.Error()
		switch {
		case errors.Is(err, jwt.ErrExpiredToken):
			status = consts.StatusUnauthorized
			msg = "Refresh token expired"
		case errors.Is(err, jwt.ErrInvalidToken):
			status = consts.StatusUnauthorized
			msg = "Invalid refresh token"
		}

		c.JSON(status, &api.AuthResp{
			Status: int32(status),
			Msg:    msg,
		})
		return
	}

	accessClaims, err := jwt.ParseToken(accessToken)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.AuthResp{
			Status: 500,
			Msg:    "Failed to parse access token: " + err.Error(),
		})
		return
	}
	refreshClaims, err := jwt.ParseToken(newRefreshToken)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.AuthResp{
			Status: 500,
			Msg:    "Failed to parse refresh token: " + err.Error(),
		})
		return
	}

	now := time.Now().Unix()
	var accessExpiresIn int64
	if accessClaims.RegisteredClaims.ExpiresAt != nil {
		accessExpiresIn = accessClaims.RegisteredClaims.ExpiresAt.Unix() - now
		if accessExpiresIn < 0 {
			accessExpiresIn = 0
		}
	}
	var refreshExpiresIn int64
	if refreshClaims.RegisteredClaims.ExpiresAt != nil {
		refreshExpiresIn = refreshClaims.RegisteredClaims.ExpiresAt.Unix() - now
		if refreshExpiresIn < 0 {
			refreshExpiresIn = 0
		}
	}

	resp := &api.AuthResp{
		Status: 200,
		Msg:    "Token refreshed",
		Data: &api.TokenPair{
			AccessToken:      accessToken,
			RefreshToken:     newRefreshToken,
			AccessExpiresIn:  accessExpiresIn,
			RefreshExpiresIn: refreshExpiresIn,
		},
	}

	c.JSON(consts.StatusOK, resp)
}

func computeExpiresIn(token string) int64 {
	claims, err := jwt.ParseToken(token)
	if err != nil || claims.RegisteredClaims.ExpiresAt == nil {
		return 0
	}
	diff := claims.RegisteredClaims.ExpiresAt.Unix() - time.Now().Unix()
	if diff < 0 {
		return 0
	}
	return diff
}
